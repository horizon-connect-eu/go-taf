package main

import (
	"crypto/sha512"
	"encoding/hex"
	"fmt"
	"github.com/vs-uulm/go-taf/internal/projectpath"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"
)

/*
main traverses all trust model directories and creates a hash.go file for each single model. These hash.go files
represent a signing hash of the contents of the trust model implementation. Changes in the trust model result in
changes of this hash.

This helper is called before the TAF is built, (go:generate), and also before the plugin handler is called.

The function expects the following structure:

	trustmodels/
	   ├── A
	   │   └── A-v0.1.0
	   │       ├── files-for-A-v0.1.0
	   │       └── hash.go
	   └── B
		   ├── B1-v0.2.0
		   │   ├── files-for-B1-v0.2.0
		   │   └── hash.go
		   └── B2-v0.2.0
		       ├── files-for-B2-v0.2.0
		       └── hash.go
*/
func main() {
	rootDir := projectpath.Root + "/plugins/trustmodels" //

	err := filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip non-directories
		if info.IsDir() {
			// Check if this directory is a sub-subdirectory (depth 2)
			relPath, _ := filepath.Rel(rootDir, path)
			parts := strings.Split(relPath, string(filepath.Separator))
			if len(parts) == 2 {
				hash, pkgName, err := hashDirectory(path)
				if err != nil {
					fmt.Printf("Error hashing directory %s: %v\n", path, err)
					return err
				}

				err = writeHashFile(path, pkgName, hash)
			}
		}

		return nil
	})

	if err != nil {
		fmt.Printf("Error writing hash.go files: %v\n", err)
		os.Exit(1)
	}

}

func hashDirectory(dir string) (string, string, error) {
	h := sha512.New()

	pkgName := ""

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip the directory itself and the "hash.go" file
		if info.IsDir() || filepath.Base(path) == "hash.go" {
			return nil
		}

		file, err := os.Open(path)
		if err != nil {
			return err
		}
		defer file.Close()

		// Update hash with file contents
		if _, err := io.Copy(h, file); err != nil {
			return err
		}

		if pkgName == "" {
			pkgName, err = packageName(path)
			if err != nil {
				return err
			}
		}

		return nil
	})

	if err != nil {
		return "", "", err
	}

	return hex.EncodeToString(h.Sum(nil)), pkgName, nil
}

func packageName(file string) (string, error) {
	fset := token.NewFileSet()

	// parse the go soure file, but only the package clause
	astFile, err := parser.ParseFile(fset, file, nil, parser.PackageClauseOnly)
	if err != nil {
		return "", err
	}

	if astFile.Name == nil {
		return "", fmt.Errorf("no package name found")
	}

	return astFile.Name.Name, nil
}

func writeHashFile(dir string, pkgName string, hash string) error {

	f, err := os.Create(dir + "/hash.go")
	if err != nil {
		log.Fatalln(err)
	}
	defer f.Close()

	packageTemplate.Execute(f, struct {
		Timestamp time.Time
		PkgName   string
		Hash      string
	}{
		Timestamp: time.Now(),
		PkgName:   pkgName,
		Hash:      hash,
	})

	log.Printf("Signing Trust Model Package \"%s\" (%s): %s", pkgName, dir, hash)

	return nil
}

var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated automatically at
// {{ .Timestamp }}
package {{ .PkgName }}

const SigningHash = "{{ .Hash }}"
`))
